# Fix taxonomy of IUCN data so it matches our Jetz-based taxonomy
# Robert MacDonald
# 29/08/2024

# load libraries
library(dplyr)

# clear environment
rm(list=ls())

# load IUCN Red List data, subset to class Aves, remove galloanseriformes and palaeognaths
# add column with scientific name separated
# by underscore
iucn_master <- readr::read_rds(
  here::here(
    "4_SharedInputData", "IUCN_RedList_data_130324.rds"
  )
) 


iucn_data <- iucn_master %>% 
  filter(
    class_name == "AVES",
    order_name != "STRUTHIONIFORMES", 
 #   IOCOrder != "RHEIFORMES", 
#    IOCOrder != "CASUARIIFORMES", 
#    IOCOrder != "APTERYGIFORMES", 
#    IOCOrder != "TINAMIFORMES", 
    order_name != "GALLIFORMES", 
    order_name != "ANSERIFORMES"
  ) %>% 
  mutate(
    species = sub(" ", "_", scientific_name)
  )

# load raw patch pixel values,
patch_master <- readr::read_rds(
  here::here(
    "2_Patches", "1_InputData", "patches.231030.rds"
  )
)

# load taxonomic data and extract species names
taxo_master <- read.csv(
  here::here(
    "4_SharedInputData", "BLIOCPhyloMasterTax_2019_10_28.csv"
  )
)



# remove gallanseriformes from patch pixel values
patch_data <- patch_master %>% 
  left_join(
    taxo_master,
    by = join_by(species == TipLabel)
  )  %>% 
  filter(
    IOCOrder != "GALLIFORMES"
  ) %>%
  select(
    species, specimen, sex, view, region, coord.x, coord.y, vR, vG, vB, uR, uG, uB, min.r2
  )

# extract patch species names
patch_names <- unique(patch_data$species)

# remove gallanseriformes and palaeognaths from taxonomy data
taxo_data <- taxo_master %>% 
  filter(
    IOCOrder != "STRUTHIONIFORMES", 
    IOCOrder != "RHEIFORMES", 
    IOCOrder != "CASUARIIFORMES", 
    IOCOrder != "APTERYGIFORMES", 
    IOCOrder != "TINAMIFORMES", 
    IOCOrder != "GALLIFORMES", 
    IOCOrder != "ANSERIFORMES"
  )

# extraxt taxonomy species names
taxo_names <- taxo_data$TipLabel

# check that all scientific names in patch data are in the taxonomy (following line should 
# produce a vector of length zero)
patch_names[!(patch_names %in% taxo_names)]

# check which names are in the IUCN taxonomy but not Jetz
iucn_extra_species <- iucn_data[iucn_data$species %in% setdiff(iucn_data$species, taxo_names), ]

# check which orders are in this group (to make sure they're Neoaves)
unique(iucn_extra_species$order_name)

# check which names are in the Jetz taxonomy but not IUCN (these are the ones we need to resolve)
jetz_extra_species <- taxo_data[taxo_data$TipLabel %in% setdiff(taxo_names, iucn_data$species), ]


# write iucn data to csv for upload to https://www.gbif.org/tools/species-lookup
# Need to write 2 csv files as max input is 6000 rows
iucn_data %>% 
  rename(
    scientificName = scientific_name,
    kingdom = kingdom_name,
    id = taxonid
  ) %>% 
  slice(
    1:6000
  ) %>% 
  write.csv(
    file = here::here(
      "4_SharedInputData", "IUCN_RedList_data_130324_Neoaves_1-6000.csv"
    )
  )
iucn_data %>% 
  rename(
    scientificName = scientific_name,
    kingdom = kingdom_name,
    id = taxonid
  ) %>% 
  slice(
    6001:nrow(.)
  ) %>% 
  write.csv(
    file = here::here(
      "4_SharedInputData", "IUCN_RedList_data_130324_Neoaves_6001-10650.csv"
    )
  )

# write UNMATCHED IUCN data to csv for upload to https://www.gbif.org/tools/species-lookup
# THIS IS THE FILE I UPLOADED TO PRODUCE THE GBIF-GENERATED NAMES USED BELOW
iucn_extra_species %>% 
  rename(
    scientificName = scientific_name,
    kingdom = kingdom_name,
    id = taxonid
  ) %>% 
  write.csv(
    file = here::here(
      "4_SharedInputData", "IUCN_RedList_data_130324_Neoaves_unmatched.csv"
    )
  )


# Load in GBIF-generated names for unmatched IUCN data
iucn_synonyms <- read.csv(
  here::here(
    "4_SharedInputData", "GBIF-species-lookup_IUCN_Neoaves_unmatched.csv"
  )
) %>% 
  mutate(
    synonym = sub(" ", "_", species)
  )

# generate whole-IUCN dataset with new GBIF synonym names
iucn_all_synonyms <- iucn_data %>% 
  mutate(
    synonym = species
  ) %>% 
  filter(
    !(species %in% iucn_extra_species$species)
  ) %>% 
  bind_rows(
    iucn_synonyms
  )

# get iucn synonyms
new_iucn_names <- iucn_all_synonyms$synonym

# check if multiple IUCN species are synonyms of single Jetz species
length(new_iucn_names) - length(unique(new_iucn_names))

# check if all patch species are in new IUCN dataset with synonym names
species_to_match <- setdiff(patch_names, new_iucn_names)
length(species_to_match)


# Looks like there are some differences, e.g. "Acanthidops_bairdii" in the patch data
# is "Acanthidops_bairdi" in the new IUCN data
# Need to manually go through and check each name generated by the line of code above
# Use BOTW to help
# Do this in Excel - here::here("4_SharedInputData", "GBIF-manual-species-lookup_IUCN_Neoaves_unmatched.csv")
# Add extra columns called "manual_species_lookup" and "source_manual_species_lookup)
# First add in species that already match between the datasets
temp_iucn_am <- iucn_data %>% 
  mutate(
    iucn_name = species,
    gbif_name = NA,
    jetz_name = species
  ) %>% 
  filter(
    !(species %in% iucn_extra_species$species)
  ) %>% 
  mutate(
    iucn_match = "already_matched",
    manual_match_source = NA
  )

# now add in species that don't already match, with their GBIF-provided synonym
# First the species whose synonym can be found in the patch data - make the Jetz
# name their GBIF synonym
gbif_matched_species <- iucn_synonyms %>% 
  mutate(
    iucn_name = sub(" ", "_", verbatimScientificName),
    gbif_name = sub(" ", "_", species),
  ) %>% 
  filter( # get species that are in patch data, don't appear in raw IUCN but do appear in GBIF-provided synonym list
    gbif_name %in% patch_data$species
  ) %>% 
  mutate(
    jetz_name = gbif_name,
    iucn_match = "gbif_lookup_matched",
    manual_match_source = NA
  ) %>% 
  select(
    iucn_name, gbif_name, jetz_name, iucn_match
  )

temp_iucn_gbif <- iucn_data %>% 
  mutate(
    iucn_name = species
  ) %>% 
  right_join(
    gbif_matched_species,
    by = "iucn_name"
  )

rm(gbif_matched_species)

# finally, add in species that don't already match, with their GBIF-provided synonym
# Subset to those whose synonyms cannot be found in the patch data (these are the ones which will
# need to be manually matched)
manual_match_species <- iucn_synonyms %>% 
  mutate(
    iucn_name = sub(" ", "_", verbatimScientificName),
    gbif_name = sub(" ", "_", species),
  ) %>% 
  filter( # get species that are in patch data, don't appear in raw IUCN and don't appear in GBIF-provided synonym list
    !(gbif_name %in% patch_data$species)
  ) %>% 
  mutate(
    jetz_name = "missing",
    iucn_match = "manually_matched",
    manual_match_source = ""
  ) %>% 
  select(
    iucn_name, gbif_name, jetz_name, iucn_match
  )
temp_iucn_manual <- iucn_data %>% 
  mutate(
    iucn_name = species
  ) %>% 
  right_join(
    manual_match_species,
    by = "iucn_name"
  )
rm(manual_match_species)

# bind all the different types of match together 
manual_lookup_csv <- bind_rows(
  temp_iucn_manual, temp_iucn_am, temp_iucn_gbif
)

# check that all iucn name species in this dataset appear in the original iucn set and 
# vice versa
setdiff(
  manual_lookup_csv$iucn_name, 
  iucn_data$species
        )

# save as csv, ready for manual lookup of synonyms
write.csv(
  manual_lookup_csv,
          file = 
            here::here(
              "4_SharedInputData", "manual_iucn_species_match.csv"
            )
  )
# can use species_to_match object to help direct lookup - this shows species which appear in the 
# patch data but not in the iucn data or gbif synonyms
species_to_match <- as.data.frame(species_to_match) %>% 
  mutate(
    looked_up_yn = "N",
    lookup_source = "",
    accept_newname = "",
    notes = ""
  )
write.csv(
  species_to_match,
  file = here::here(
    "4_SharedInputData", "patch_species_to_match_write.csv"
  )
)


# ---------------------------------------------------------------------------------------#
# ATTEMPT 2 - Using AVONET taxonomy matcher
# Downloaded from AVONET supplementary data repository
# https://figshare.com/s/b990722d72a26b5bfead

# load AVONET BirdLife-BirdTree crosswalk
# takes a little while because of the name cleaning
avonet_crosswalk <- read.csv(
  here::here(
    "4_SharedInputData", "avonet", "avonet_v7_birdlife-birdtree-crosswalk.csv"
  )
) %>% 
  rename(
    species_birdlife = Species1,
    species_birdtree = Species3,
    match_type = Match.type,
    match_notes = Match.notes
  ) %>% 
  mutate(
    species_birdlife = sub(" ", "_", species_birdlife),
    species_birdtree = sub(" ", "_", species_birdtree),
    match_type = snakecase::to_snake_case(match_type)
  )

# we can filter out newly described species as these are all species that don't exist in the 
# birdtree taxonomy
# # There are 4 species in the BT taxonomy that are marked as "invalid taxon" and don't have 
# a BL taxonomy name. These are Anthus_longicaudatus, Hypositta_perdita, Lophura_hatinhensis, 
# and Phyllastrephus_leucolepis. None of these species are in the patch data, so we can remove them
# There are also 143 extinct species which have no BT name. Keep these in, as we may get data on 
# extinct species in the future
avonet_crosswalk <- avonet_crosswalk %>% 
  filter(
    match_type != "newly_described_species",
    match_type != "invalid_taxon"
  )

# Check number of species in each mapping type group (1 BL to 1 BT, 1 BL to many BT, many BL to 1 BT,
# extinct)
avonet_crosswalk %>% 
  group_by(match_type) %>% 
  summarise(
    n = n()
  )

## OK - here is where the actual taxonomy matching starts ----

# get full Aves IUCN data
iucn_aves <- iucn_master %>% 
  filter(
    class_name == "AVES",
  ) %>% 
  mutate(
    species = sub(" ", "_", scientific_name),
  ) %>% 
  rename(
    species_birdlife = species
  )

# first need to check that all species for which we have data appear in the AVONET BirdTree taxonomy
# identify any species which don't appear
patch_names[which(!(patch_names %in% avonet_crosswalk$species_birdtree))]
# Campylopterus_curvipennis doesn't appear. This is because it has since been renamed
# "Pampa_curvipennis" (as per IUCN Red List website, accessed 04/09/2024)


# Let's change the BirdTree name from "Pampa_curvipennis" to "Campylopterus_curvipennis"
avonet_crosswalk_checked <- avonet_crosswalk %>% 
  mutate(
    species_birdtree = if_else(species_birdtree == "Pampa_curvipennis", "Campylopterus_curvipennis", species_birdtree)
  )


# Check for species which are in my IUCN data (2023 data) but not in the AVONET crosswalk (
# which uses the HBW-BirdLife Version 5.0 (December 2020) checklist, accessed 18/06/2021)
# this gives the current IUCN name of the species
missing_birdlife_species <- iucn_aves$species_birdlife[which(!(iucn_aves$species_birdlife %in% avonet_crosswalk_checked$species_birdlife))] %>% 
  sort()

# to rectify the missing BirdLife species, I can compare version 5.0 of the BirdLife digital checklist
# (used by AVONET) with version 8.1 (which I believe is the version used by my IUCN data)
# Just need to replace the IUCN 2023 species names (v8.1) with their v5.0 names, where possible


# use a csv version of the 8.1 checklist and a csv version of the
# 5.0 checklist loaded into R
# load v8.1 and discard rows referring to subspecies
bl_81 <- readr::read_csv(
  here::here(
    "4_SharedInputData", "birdlife_taxonomic_checklists", "v8.1",
    "simplified_rxm_digital_checklist_v81.csv"
  ), 
  skip_empty_rows = TRUE
) %>% 
  filter(
    is.na(SubsppID)#,
    # iucn_cat_2023 != "NR"
  ) %>% 
  select(
    -c(subsp_seq, authority, alt_common_names, SubsppID)
  ) %>% 
  mutate(
    species_81 = sub(" ", "_", scientific_name)
  )
# load v5.0 and filter out not recognised complexes
bl_50 <- readr::read_csv(
  here::here(
    "4_SharedInputData", "birdlife_taxonomic_checklists", "v5.0",
    "simplified_rxm_digital_checklist_v50.csv"
  ),
  skip_empty_rows = TRUE
) %>% 
  mutate(
    species_50 = sub(" ", "_", scientific_name)
  ) %>% 
  filter(
    iucn_cat_50 != "NR",
    iucn_cat_50 != "UR"
  ) %>% 
  select(
    species_50, SpcRecID
  )

# check if there are any species which are in the IUCN 2023 data but not the BL v8.1 checklist
iucn_aves$species_birdlife[which(!(iucn_aves$species_birdlife %in% bl_81$species_81))]
# nope, all good - the versions match

# join the birdlife v8.1 checklist to the v5.0 checklist (using SpcRecID) and 
# ilter to only the species which are missing from the AVONET crosswalk data
# PROBLEM WITH THIS CODE - it filters out species which are in bl_50 but not bl_81 (e.g. Amazilia lactea)
# - this is a problem if these species are in patch data
bl_checklist_match <- bl_50 %>% 
  full_join(
    bl_81, by = "SpcRecID"
  ) %>% 
  # filter(
  #   species_81 %in% missing_birdlife_species | species_50 %in% missing_birdlife_species
  # ) %>% 
  select(
    -c(seq, order, family_name, family, subfamily, tribe, common_name, scientific_name, synonyms, taxonomic_sources, SISRecID, invalid)
  )

# check which 5.0 species don't have an 8.1 name equivalent
missing_50s <- bl_checklist_match %>% 
  filter(
    is.na(species_81)
  )
missing_50s
# 4 species ("Phyllastrephus_xavieri", "Megalurus_timoriensis", "Cacicus_cela", "Cacicus_uropygialis")
# manually check these using IUCN red list website (accessed 2024-09-23) and manually add their 
# v8.1 names
 
# First convert to df for manipulation
bl_checklist_match <- as.data.frame(bl_checklist_match)

# Phyllastrephus_xavieri - 
# examine 5.0 entry
bl_checklist_match[which(bl_checklist_match$species_50 == "Phyllastrephus_xavieri"), ]
# check if in 8.1 data under different SpcRecID - appears but no SpcRecID
bl_checklist_match[which(bl_checklist_match$species_81 == "Phyllastrephus_xavieri"), ]
# Have manually checked v8.1 checklist - appears but has no SpcRecID
# ---> Merge rows
bl_checklist_match[which(bl_checklist_match$species_50 == "Phyllastrephus_xavieri"), "iucn_cat_81"] <- bl_checklist_match[which(bl_checklist_match$species_81 == "Phyllastrephus_xavieri"), "iucn_cat_81"]
bl_checklist_match[which(bl_checklist_match$species_50 == "Phyllastrephus_xavieri"), "species_81"] <- "Phyllastrephus_xavieri"

# Megalurus_timoriensis
# examine 5.0 entry
bl_checklist_match[which(bl_checklist_match$species_50 == "Megalurus_timoriensis"), ]
# check if in 8.1 data under different SpcRecID - doesn't appear
bl_checklist_match[which(bl_checklist_match$species_81 == "Megalurus_timoriensis"), ]
# BOTW.org says now known as Cincloramphus timoriensis - check if this appears in 8.1 data
bl_checklist_match[which(bl_checklist_match$species_81 == "Cincloramphus_timoriensis"), ]
# yep - no SpcRecID
# ---> Merge rows
bl_checklist_match[which(bl_checklist_match$species_50 == "Megalurus_timoriensis"), "iucn_cat_81"] <- bl_checklist_match[which(bl_checklist_match$species_81 == "Cincloramphus_timoriensis"), "iucn_cat_81"]
bl_checklist_match[which(bl_checklist_match$species_50 == "Megalurus_timoriensis"), "species_81"] <- "Cincloramphus_timoriensis"

# Cacicus_cela
# examine 5.0 entry
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_cela"), ]
# check if in 8.1 data under different SpcRecID - appears but no SpcRecID
bl_checklist_match[which(bl_checklist_match$species_81 == "Cacicus_cela"), ]
# Have manually checked v8.1 checklist - appears but has no SpcRecID
# ---> Merge rows
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_cela"), "iucn_cat_81"] <- bl_checklist_match[which(bl_checklist_match$species_81 == "Cacicus_cela"), "iucn_cat_81"]
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_cela"), "species_81"] <- "Cacicus_cela"

# Cacicus_uropygialis
# examine 5.0 entry
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_uropygialis"), ]
# check if in 8.1 data under different SpcRecID - appears but with a different SpcRecID
bl_checklist_match[which(bl_checklist_match$species_81 == "Cacicus_uropygialis"), ]
# Have manually checked v5.0 and v8.1 checklist - looks like it was lumped prior to v5.0 and then
# split again for v8.1 (into Cacicus_uropygialis and C. microrhynchus)
# Both have the same IUCN category (LC) so can merge rows
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_uropygialis"), "iucn_cat_81"] <- bl_checklist_match[which(bl_checklist_match$species_81 == "Cacicus_uropygialis"), "iucn_cat_81"]
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_uropygialis"), "SpcRecID"] <- bl_checklist_match[which(bl_checklist_match$species_81 == "Cacicus_uropygialis"), "SpcRecID"]
bl_checklist_match[which(bl_checklist_match$species_50 == "Cacicus_uropygialis"), "species_81"] <- "Cacicus_uropygialis"

#remove duplicate rows
bl_checklist_match_filtered <- bl_checklist_match %>% 
  filter(
    !(species_81 == "Phyllastrephus_xavieri" & is.na(species_50)),
    !(species_81 == "Cincloramphus_timoriensis" & is.na(species_50)),
    !(species_81 == "Cacicus_cela" & is.na(species_50)),
    !(species_81 == "Cacicus_uropygialis" & is.na(species_50))
    
  )
# check it's worked (should produce character(0))
bl_checklist_match_filtered %>% 
  filter(
    is.na(species_81)
  )

# identify rows which have both an non-NR and NR iucn_cat_81
dupes_NR_nonNR <- bl_checklist_match_filtered[bl_checklist_match_filtered$species_81 %in% unique(bl_checklist_match_filtered$species_81[duplicated(bl_checklist_match_filtered$species_81)]), ]

# use a for loop to remove the NR rows (for species which have a non-NR value as well)
duplicated_spp <- unique(bl_checklist_match_filtered$species_81[duplicated(bl_checklist_match_filtered$species_81)]) %>% 
  sort()
for(sp in duplicated_spp){
  dupe_rows <- bl_checklist_match_filtered %>% 
    filter(
      species_81 == sp
    )
  # remove NR IF there's a non-NR row as well
  if(length(dupe_rows$iucn_cat_81[dupe_rows$iucn_cat_81 != "NR"]) != 0){
    bl_checklist_match_filtered <- bl_checklist_match_filtered %>% 
      filter(
        !(species_81 == sp & iucn_cat_81 == "NR")
      )
  }
}
  

# now use this filtered data to replace the 2023 IUCN species names with the v5.0 species names
# in the IUCN dataset (for species with missing names only)
# "species_birdlife" column now has the v5.0 names - original 2023 IUCN names preserved in
# "species_iucn_2023" column
iucn_aves_v50 <- iucn_aves %>% 
  left_join(
    bl_checklist_match_filtered,
    by = join_by(species_birdlife == species_81)
  ) %>% 
  mutate(
    species_iucn_2023 = species_birdlife
  ) %>% 
  mutate(
    species_birdlife = ifelse(!is.na(species_50), species_50, species_birdlife)
  ) %>% 
  select(
    -species_50
  )


# Join the IUCN data to the avonet crosswalk and add 'final' IUCN category for final category
# which has been manually checked, if necessary. For the one-to-one mapped species, this is the 
# same as the 'initial' IUCN category
avonet_iucn <- iucn_aves_v50 %>% 
  select(
    order_name, family_name, genus_name, species_birdlife, category
  ) %>% 
  full_join(
    avonet_crosswalk_checked,
    by = "species_birdlife"
  ) %>% 
  rename(
    initial_category = category
  ) %>% 
  mutate(
    final_category = NA
  )



# When it comes to adding in the data from the second round of image collection (August-October 2024),
# we can just filter this by the new data species so we avoid rechecking the whole thing
avonet_iucn <- avonet_iucn %>% 
  filter(
    species_birdtree %in% patch_names
  )

# Check for rows which are NA for initial category
na_init_iucn <- avonet_iucn %>% 
  filter(
    is.na(initial_category)
  )


# make final category the same as initial category for the one-to-one mapped species
avonet_iucn <- avonet_iucn %>% 
  mutate(
    final_category = if_else(match_type == "1_bl_to_1_bt", initial_category, final_category)
  )

# we can do the same for extinct species. Note that there are several species which the AVONET
# crosswalk classifies as extinct but are not classified as extinct by IUCN, so we need to assign the 
# initial_category as the final_category, rather than just assigning "EX"
avonet_iucn <- avonet_iucn %>% 
  mutate(
    final_category = if_else(match_type == "extinct", initial_category, final_category)
  )

# check for any duplicate BT species that are not assigned as "many_bl_to_1_bt"
dupes <- avonet_iucn$species_birdtree[duplicated(avonet_iucn$species_birdtree) & avonet_iucn$match_type != "many_bl_to_1_bt"]
avonet_iucn %>% 
  filter(
    species_birdtree %in% dupes
  ) %>% 
  View()
# these are all taxa with imperfect matches where a single BirdTree species is assigned to 
# multiple BirdLife species
# Don't know why these aren't assigned as "many_bl_to_1_bt" - assign as that 
avonet_iucn <- avonet_iucn %>% 
  mutate(
    match_type = if_else(species_birdtree %in% dupes, "many_bl_to_1_bt", match_type)
  )


# filter to just species with many BL species corresponding to 1 BT species - we can just average
# the IUCN category for these species. 
many_bl_1_bt <- avonet_iucn %>% 
  filter(
    match_type == "many_bl_to_1_bt"
  ) 

# We can remove any species in this list that have only one BT species - these are species which
# were previously split in (AVONET) BL taxo but have been lumped in the newer IUCN BL taxo 
# (e.g. Rhea pennata was split into Rhea pennata and Rhea tarapacensis but is lumped in BT and
# has now been lumped in the newer IUCN data)
# Let's just double check these species manually with the IUCN website (there are only 15)
# 16/09/14 - NEED TO DOUBLE CHECK THESE AGAIN MANUALLY
lumped_species <- many_bl_1_bt %>% 
  group_by(
    species_birdtree
  ) %>% 
  filter(n() == 1)
lumped_species

# Once these species have been checked manually (NOT completed), we can assign their initial_category as
# their final_category
avonet_iucn <- avonet_iucn %>% 
  mutate(
    final_category = if_else(species_birdtree %in% lumped_species$species_birdtree, initial_category, final_category)
  )

# now let's get a list of many_bl_to_1_bt species - filter out the species we've just manually checked,
many_bl_1_bt <- avonet_iucn %>% 
  filter(
    match_type == "many_bl_to_1_bt"
  ) %>% 
  group_by(
    species_birdtree
  ) %>% 
  filter(n() > 1)

# for these species, we can automatically assign their final IUCN category as the same as their initial
# IUCN category IF the initial IUCN category is the same for all split BL species mapped to each BT
# species
# loop to do this
bt_spec <- unique(many_bl_1_bt$species_birdtree)
for(spec in bt_spec){
  # check if all BL species have the same IUCN category - assign as final category if so
  iucn_cats <- unique(many_bl_1_bt$initial_category[many_bl_1_bt$species_birdtree == spec])
  if(
    length(iucn_cats) == 1
  ){
    avonet_iucn <- avonet_iucn %>% 
      mutate(
        final_category = if_else(species_birdtree == spec, initial_category, final_category)
      )
  }
}

# check how many "many_bl_to_1_bt" species still have no final IUCN category
avonet_iucn %>% 
  filter(
    match_type == "many_bl_to_1_bt",
    is.na(final_category)
  ) %>% 
  count()
# 603 species left - these are species for which the species which are split in the BL taxonomy
# (but are a single species in the BT taxonomy) have different IUCN categories
# These species will need to be assigned a category somehow - conservative (assign highest cat)?
# liberal (assign lowest cat)? or random

#-------# 
# INSERT CODE HERE TO DEAL WITH THE REMAINING many_bl_to_1_bt" SPECIES
#-------#

# now let's deal with the species for which many BirdTree species are assigned as a single 
# BirdLife species (match_type == "1_bl_to_many_bt"). These can just be assigned the IUCN category
# of the single BirdLife species (nothing else we can do, I don't think, other than
# trying to get regional Red List data)
# First count how many there are
avonet_iucn %>% 
  filter(
    match_type == "1_bl_to_many_bt"
  ) %>% 
  count()

# again, for these ones we can just assign the same final category as initial category
avonet_iucn <- avonet_iucn %>% 
  mutate(
    final_category = if_else(match_type == "1_bl_to_many_bt", initial_category, final_category)
  )

# Now we can remove any duplicate BirdTree species, as these should all be "many_bl_to_1_bt" species
# which have had their final category assigned
# just double check that there are no stray duplicates with other match_types
avonet_iucn$species_birdtree[duplicated(avonet_iucn$species_birdtree) & avonet_iucn$match_type != "many_bl_to_1_bt"]
# now remove the duplicate rows
avonet_iucn <- avonet_iucn %>% 
  distinct(
    species_birdtree, .keep_all = TRUE
  )

# Pending decision on how to deal with the many_bl_to_1_bt species where the multiple BL species
# have different IUCN categories, we should now be done with the taxonomy matching

# try joining to the patch data, for example
patch_dat <- as.data.frame(patch_names)
patch_dat <- patch_dat %>% 
  left_join(
    avonet_iucn,
    by = join_by(patch_names == species_birdtree)
  )

# still some missing iucn values - let's check them out, filtering out the many_bl_to_1_bt
# species (because I haven't finalised what to do with those yet)
missing_patch_dat <- patch_dat %>% 
  filter(
    match_type != "many_bl_to_1_bt"
  )

# there seem to be a bunch of rows that have NA for everything except patch_name - why?????
missing_patch_dat <- patch_dat %>% 
  filter(
    is.na(match_type)
  )

# OK - solved it. There are ~370 species in my IUCN dataset that are NOT in the AVONET crosswalk
# BirdLife species list
iucn_aves$species_birdlife[which(!(iucn_aves$species_birdlife %in% avonet_crosswalk_checked$species_birdlife))] %>% 
  sort()
# I'm guessing this is probably because the BirdLife taxonomy has been updated since AVONET was released
# I think the  solution to this will probably be to manually check the new/old name of each species
# NO WAIT - actually I can use the HBW/BirdLife taxonomic checklist, which also contains the IUCN
# status!
# https://datazone.birdlife.org/species/taxonomy
# I can use this, together with the archive of earlier versions of the checklist, to match the new
# and old names
